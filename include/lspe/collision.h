#pragma once

/********************************
 *  @author: ZYmelaii
 *
 *  @collision: intro for collision
 *
 *  @brief: use GJK + EPA / MPR algorithm
 *
 *  @NOTES: 
 *******************************/

#include "../lspe/base/base.h"
#include "../lspe/base/vec.h"
#include "../lspe/base/mat.h"
#include "../lspe/shape.h"

namespace lspe
{

class Arbiter;
class Collider;

namespace collision
{

//! customizable support function for GJK/EPA/MPR algorithm
//! it should return the maximum point of the projection
//! of the shape in the given direction
//! you should assume that the shape is of expected type
//! there will be no redundant checks inside the algorithm
//! tip: Shape is a pointer pointed to real shape object
typedef vec2 (*fnsupport)(Shape x, const vec2 &direction);

//! this is an extended version of fnsupport
//! it allows more given params to spawn a vec2
typedef vec2 (*fnsupport2)(Shape x, Shape y, const vec2 &v, void *extra);

vec2 supportLine    (Shape x, const vec2 &direction);
vec2 supportCircle  (Shape x, const vec2 &direction); //$ DONE
vec2 supportPolygen (Shape x, const vec2 &direction); //$ DONE
vec2 supportEllipse (Shape x, const vec2 &direction); //$ DONE
vec2 supportBezier2 (Shape x, const vec2 &direction);
vec2 supportBezier3 (Shape x, const vec2 &direction);

};

class Arbiter
{
public:
	Arbiter() = delete;
	Arbiter(const Arbiter &a) = delete;

	Arbiter(Collider *collider, size_t maxIter = 16);
	~Arbiter();

	void setEps(float eps);

	void resetCollider(Collider *collider);

	bool isActive() const;
	bool isCollided() const;

	void getPenetration(vec2 *penetrationVector) const;
	void getPenetration(vec2 *normal, float *distance) const;

	void getClosetPoint(vec2 *a, vec2 *b) const;

	//! perform further detection
	//! return true if everything done
	//! otherwise return false
	bool perform();

protected:
	void getClosetPoint();
	void getContacts();

private:
	struct MetaPoint
	{
		vec2 point;
		vec2 fromA;
		vec2 fromB;
	};

	struct MetaEdge
	{
		int aId;
		int bId;
		float perpDistance;
	};

	using MinkowskiSubtractionSet = std::vector<MetaPoint>;
	using MinkowskiEdges = std::vector<MetaEdge>;
	using Indicies = std::vector<int>;

	//! needed by EPA performance
	MinkowskiSubtractionSet M;
    MinkowskiEdges          E;
	Indicies                I;

	//! get from Collider
	Shape                shapes[2];
	collision::fnsupport support[2];

	//! perform results
	bool collided;
	struct { vec2 normal; float distance; } penetration;
	vec2 closetPoint[2];

	//! whether Arbiter binds a valid Collider
	bool active;

	float epsilon;
	size_t maxIteration;
};

class Collider
{
public: friend class Arbiter;
public:
	Collider();

	//! test collision
	//! this may not absolutely right
	//! final result of collision test will be decided by Arbiter
	bool collided();

public:

	//! note: functions below must be called one by one
	//! before you start the collision test

	//! decide the two shapes to test collision
	void setTestPair(Shape a, Shape b);

	//! bind support function for (a, b)
	void bindSupports(
		collision::fnsupport support1,
		collision::fnsupport support2);

	//! bind generator to decide the first direction
	//! it is wanted by GJK/EPA algorithm
	void bindInitialGenerator(
		collision::fnsupport2 generator);

	//! bind an extra pointer to Collider
	//! it can be used within any callback function
	//! whose type is fnsupport2 or Collider::fndebug
	void bindExtraData(void *extra);
	void* getExtraData();

	//! clear status collision test
	//! call it before you perform a second test
	void reset();

protected:
	//! add a point of simplex
	void addSimplexPoint(vec2 direction);

	//! determine whether the generated simplex contains the origin
	//! wanted by collided()
	bool simplexContainOrigin(vec2 &direction);

private:
	Shape shapes[2];
	collision::fnsupport2 getfirstdirection;
	collision::fnsupport support[2];
	void *extra;

	//! simplex is generated by collided()
	//! for each simplex point simplex[i] = fromA[i] - fromB[i]
	vec2 simplex[3];
	vec2 fromA[3], fromB[3];
	int simplexIndex;

	//! mark whether Collider has performed the collision test
	//! only when tested, getArbiter() is allowed
	bool tested;
	bool iscollided;

	//! it will decide whether a collision test is allowed
	//! note: available only when DEBUG was defined
	int flag;

};

};
